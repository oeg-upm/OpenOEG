{
  "message": "SYSTEM: StreamingDataAccess_ISWC2010.pdf: Página 9\nwhere ts, te deﬁne the start and end of the window time range respectively, and\nmay be deﬁned relative to the evaluation time τ. Note that the rate at which\nwindows get evaluated is controlled by the STEP deﬁned in the query, which is\ndenoted by δ.\nWe deﬁne the three window-to-stream operators as\nRStream((ωτ, τ)) = {(⟨s, p, o⟩, τ) | ⟨s, p, o⟩∈ωτ}\nIStream((ωτ, τ), (ωτ−δ, τ −δ)) = {(⟨s, p, o⟩, τ) | ⟨s, p, o⟩∈ωτ, ⟨s, p, o⟩/∈ωτ−δ}\nDStream((ωτ, τ), (ωτ−δ, τ −δ)) = {(⟨s, p, o⟩, τ) | ⟨s, p, o⟩/∈ωτ, ⟨s, p, o⟩∈ωτ−δ}\nwhere δ is the time interval between window evaluations. Note that RStream\ndoes not depend on the previous window evaluation, whereas both IStream and\nDStream depend on the contents of the previous window.\nWe have provided a brief explanation of the semantics of sparqlStream. This\nis particularly useful in the sense that users may know what to expect when they\nissue a query using these new operators. However, as the actual data source is not\nan rdf stream but a sensor network or an event-based stream, e.g. exposed as\na sneeql endpoint, we need to transform the sparqlStream queries into sneeql\nqueries. The next section describes the semantics of the transformation from\nsparqlStream to sneeql using the S2O mappings.\n5.2\nS2O Semantics\nIn this section we will present how we can use the S2O mapping deﬁnitions\nto transform a set of conjunctive queries over an ontological schema, into the\nstreaming query language sneeql that is used to access the sources. This work\nis based on extensions to the ODEMapster processor [1] and the formalisation\nwork of Calvanese et al. [19] and Poggi et al. [20].\nA conjunctive query q over an ontology O can be expressed as:\nq(x) ←ϕ(x, y)\nϕ(x, y) :\n^\ni=1...k\nPi, with Pi\n\n\n\n\n\nCi(x), C is an atomic class.\nRi(x, y), R is an atomic property.\nx = y\nx, y are variables either in x, y or constants.\nwhere x is a tuple of distinct distinguished variables, and y a tuple of non-\ndistinguished existentially quantiﬁed variables. The answer to this query consists\nin the instantiation of the distinguished variables [19]. For instance consider:\nq1(x) ←WindSpeedMeasurement(x) ∧measuredBy(x, y) ∧WindSensor(y)\nIt requires all instances x that are wind speed measurements captured by wind\nsensors. In this example x is a distinguished variable and y a non-distinguished\n9\n",
  "speaker": "SYSTEM",
  "uuid": "e772518a-0025-4ee0-80c9-2eca9b351567"
}