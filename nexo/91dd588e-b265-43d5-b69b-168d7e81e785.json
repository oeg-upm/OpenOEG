{
  "message": "SYSTEM: Eswc2010webofdatatrack_submission_2.pdf: Página 4\nSuch analysis can be already found in the literature. In [1] the authors demonstrate \nthat Relational Algebra under bag semantics and the W3C SPARQL specification \nhave the same expressive power. The authors base this claim in the fact that \nRelational algebra has the same expressive power than non-recursive Datalog with \nnegation (nr-Datalog). Together with the previous demonstration, they show that \nSPARQL with compositional semantics is equivalent to nr-Datalog with negation. In \n[13] the authors demonstrate that SPARQL and SPARQL with compositional \nsemantics are equivalent to the W3C SPARQL specification. Therefore we can claim \nthat using a relational algebra representation in our system we will not have a relevant \nimpact in terms of losing expressivity.  \nPreviously, in [4] the author also claims that SQL Logical Query Plans (LQPs) \nmay be used to represent the most common SPARQL queries. These LQPs use equi-\njoins for grouping triple patterns and left outer joins for handling optionals in queries. \nAs a result, most of the SPARQL queries can be actually transformed to SQL without \nlosing any expressivity and preserving the query semantics. The author specifies as \nwell a set of limitations and mismatches between SPARQL and Relational Algebra. \nThese mismatches can be summarized as follows: the different behavior of Relational \nAlgebra and SPARQL with unbound variables (SPARQL does not take into account \nnull values - they are left in blank -, while the relational model specifies the null \nvalue), different join behavior with missing information (due to the previous problem \nof null values and blank nodes), nested optional problems (for the same reason) and \ndifferent filter scope (in which FILTER may not affect the right triple pattern). These \nlimitations will be addressed in further iterations of our solution, as specified in the \nfuture work section of this paper. \nFinally in [13] the authors describe the semantics of SPARQL and its complexity, \nwhich is not addressed in the aforementioned references. They define the concept of \nwell-designed patterns for SPARQL queries, which impose restrictions on how to \nwrite SPARQL queries in order to ensure a low complexity in their treatment and the \npossibility of applying optimizations in query plans9. Well-designed patterns are those \nwhere every variable occurring in the first part of a query occurs in both the first part \nof the pattern and in the last. For instance, an AND-FILTER-OPT pattern is well–\ndesigned if for every OPT in the pattern (...( A OPT B )...) if a variable occurs inside \nB and anywhere outside the OPT operator, then the variable also occurs inside A. \nFollowing this approach, we limit the queries to be handled in our system to those \nfollowing well-designed patterns.  \n2.2 Distributed Query Processing \nOnce we have analyzed the relationship between SPARQL and relational algebra, we \nmove into describing the most important components of a DQP system [9]. Figure 1 \nshows a generic architecture for a DQP system, which considers the following \ncomponents: query parser, query rewriter, query optimizer, plan refinement \ncomponent and query execution engine. The parser reads the query and transforms it \ninto the system’s internal representation. Next, the query rewriter creates a Logical \n                                                           \n9 The complexity of well-designed patterns is coNP-complete [13]. \n",
  "speaker": "SYSTEM",
  "uuid": "91dd588e-b265-43d5-b69b-168d7e81e785"
}