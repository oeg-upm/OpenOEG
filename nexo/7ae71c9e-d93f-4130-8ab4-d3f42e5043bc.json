{
  "message": "SYSTEM: OntologyDebugging_KCAP2009.pdf: Página 2\ning OWL ontologies, based on existing ontology design \npatterns and knowledge patterns and anti-patterns.  \nIn this paper we propose a detailed list of such anti-patterns, \ncompiling all the relevant cases that we came across when \nhelping ontology developers to debug their ontologies. \nThen we provide some hints about how to organise the it-\nerative ontology debugging process using a combination of \ndebugging tools and patterns, and we describe the most \ncommon alternatives to tackle these anti-patterns.  \n2. PATTERNS AND ANTI-PATTERNS  \nIn software engineering, a design pattern can be defined as \na general, proven and beneficial solution to a common re-\noccurring problem in software design [2]. Built upon simi-\nlar experiences, design patterns represent best practices \nabout how to build software. On the contrary, antipatterns \nare defined as patterns that appear obvious but are ineffec-\ntive or far from optimal in practice, representing worst prac-\ntice about how to structure and build software [6].  \nIn knowledge (and more specifically in ontology) engineer-\ning the concept of knowledge modelling (ontology design) \npattern is used to refer to modelling solutions that allow \nsolving recurrent knowledge modelling or ontology design \nproblems [1, 9, 10, 11]. A similar definition is given for \nknowledge modelling (or ontology design) anti-patterns. \nDifferent types of ontology design patterns are defined [9]:  \nLogical Ontology Design Patterns (LP) are independent \nfrom a specific domain of interest, but dependent on the \nexpressivity of the logical formalism used for representa-\ntion. For example, the n-ary relation pattern enables to \nmodel n-ary relations in OWL DL ontologies ([9, 17]). \nArchitectural Ontology Design Patterns (AP) provide \nrecommendations about the structure of an ontology. They \nare defined in terms of LPs or compositions of them. Ex-\namples are: taxonomy or lightweight ontology [9]. \nContent Ontology Design Patterns (CP) propose domain-\ndependent conceptual models to solve content design prob-\nlems for the domain classes and properties that populate an \nontology. They usually exemplify LPs, and they represent \nmost of the work done on ontology design patterns.  \nIn contrast to ontology design patterns, the work on anti-\npatterns is less detailed ([7, 12]). Four LAPs are presented \nin [7], all of them focused on property domains and ranges. \nAnd [12] describes common difficulties for newcomers to \ndescription logics in understanding the logical meaning of \nexpressions. However, none of these contributions groups \nanti-patterns in a common classification, nor provide a \ncomprehensive set of hints to debug them. \n2.1 A Classification of Ontology Design Anti-\nPatterns \nWe have identified a set of patterns that are commonly used \nby domain experts in their DL formalisations and OWL \nimplementations, and that normally result in inconsisten-\ncies. We have categorized them into three groups: \n• \nLogical Anti-Patterns (LAP). They represent errors that \nDL reasoners detect. These are the ones for which tool \nsupport is easier to provide and hence some support al-\nready exists. \n• \nNon-Logical (aka Cognitive) Anti-patterns (NLAP). \nThey represent possible modelling errors that are not \ndetected by reasoners (they are not logical but model-\nling errors, which may be due to a misunderstanding of \nthe logical consequences of the used expression). \n• \nGuidelines (G). They represent complex expressions \nused in an ontology component definition that are cor-\nrect from a logical point of view, but in which the on-\ntology developer could have used other simpler alter-\nnatives for encoding the same knowledge.  \nIn the rest of this section we describe each of the anti-\npatterns identified in each group, providing their name and \nacronym, their template logical expressions and a brief ex-\nplanation of why this anti-pattern can appear and how it \nshould be checked by the ontology developer. As aforemen-\ntioned, it is important to note that LAP are identified by \nexisting ontology debugging tools, although the information \nthat is provided back to the user explaining the reason for \nthe inconsistency is not described according to such a pat-\ntern, what makes it difficult for ontology developers to find \nout where the inconsistencies are coming from. With re-\nspect to NLAP and G, they are not currently detected by \nthese tools as such, although in some cases their combina-\ntion may lead into inconsistencies that are detected (al-\nthough not appropriately explained) by tools. As we men-\ntion in our future work section, we think that tool support \nfor them could be a major step forward in this task. \nFinally, all these anti-patterns should be seen as elementary \nunits that cause ontology inconsistencies. That is, they can \nbe combined into more complex ones. However, providing \na solution for the individual ones is already a good advance \nto the current state of the art, and our future work will be \nalso devoted to finding the most common combinations and \nproviding recommendations for them. \n2.2 Logical Antipatterns \nAntiPattern AndIsOr (AIO) \nC1⊆ ∃R.(C2∩C3), disj(C2,C3)2 \nThis is a common modelling error that appears due to the \nfact that in common linguistic usage, “and” and “or” do not \ncorrespond consistently to logical conjunction and disjunc-\ntion respectively [12]. For example, I want a cake with milk \nand chocolate is ambiguous. Does the cake recipe contain? \n                                                           \n2 This does not mean that the ontology developer has explicitly \nexpressed that C2 and C3 are disjoint, but that these two con-\ncepts are determined as disjoint from each other by a reasoner. \nWe use this notation as a shorthand for C2∩C3⊆⊥. \n",
  "speaker": "SYSTEM",
  "uuid": "7ae71c9e-d93f-4130-8ab4-d3f42e5043bc"
}