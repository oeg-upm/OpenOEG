{
  "message": "SYSTEM: BUSQUEDA.pdf: Página 48\nBÚSQUEDA \n \n48 \nJ. Rubio / P.R. Muro / J. Bañares \n \nOctubre 2004 - Curso 2004-2005 \n \n> (setq tmp x)  ===> \n8 \n \n> (setq x y) \n ===> \n5 \n \n> (setq y tmp)  ===> \n8 \n¿Podemos hacerlo con una única evaluación? Para ello necesitamos componer \nsecuencialmente varias instrucciones Common Lisp. Esto es lo que permite hacer la \nprimitiva progn (recuérdese que el cuerpo de defun es un progn implícito). Se \ntrata de una función que permite construir un bloque de sentencias: cada uno de los \nobjetos que son sus argumentos son evaluados, devolviéndose como valor el del \núltimo objeto evaluado. Por ejemplo (estamos suponiendo que vamos evaluando \ntodas las expresiones desde el principio del apartado): \n \n> (progn \n \n \n(setq tmp x) \n \n \n(setq x y) \n \n \n(setq y tmp)) \n \n ===> \n5 \nSin embargo, la anterior solución no es totalmente satisfactoria, pues la variable \nglobal tmp habrá cambiado su valor definitivamente, lo cual es un efecto lateral que \nno estaba especificado al enunciar el problema al comienzo del apartado. Si \nqueremos tener una versión más segura debemos ser capaces de definir bloques de \nsentencias con contexto local. Esto puede lograrse utilizando la primitiva let. Así \npara resolver el problema anterior, podríamos evaluar: \n \n> (let ((tmp x)) \n \n \n(setq x y) \n \n \n(setq y tmp)) \n \n===> 8 \n \n> \ntmp  ===> 5 \nNótese que el valor de tmp al terminar la evaluación del let es el mismo que había \nantes de la evaluación: durante la evaluación del let el valor local de tmp ha hecho \nsombra al valor global de tmp, pero al terminar la evaluación la ligadura local ha sido \ndesactivada (es el mismo efecto que puede observarse con la ligadura de los \nparámetros formales durante la llamada a una función definida con defun). \nObsérvese también que el cuerpo del let (el texto que sigue a la ligadura de las \nvariables locales) es un progn implícito (sin paréntesis adicionales, por tanto). Por \núltimo, véase que el primer argumento para let, que no será evaluado (eso implica \nque let es un elemento especial), es una lista de listas (una lista de listas con dos \nmiembros en las que el primer miembro es un símbolo, para ser más precisos). Ello \n",
  "speaker": "SYSTEM",
  "uuid": "82478033-5265-435b-aebc-873a1610b49d"
}