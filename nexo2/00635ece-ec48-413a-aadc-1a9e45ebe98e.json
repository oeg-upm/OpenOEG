{
  "message": "SYSTEM: BUSQUEDA.pdf: Página 51\nBÚSQUEDA \n \n51 \nJ. Rubio / P.R. Muro / J. Bañares \n \nOctubre 2004 - Curso 2004-2005 \nactualización (en el ejemplo: (+ i 1)) y tras la evaluación de todos ellos, sus \nvalores son ligados a los símbolos correspondientes, procediéndose a continuación \ncomo tras la inicialización. \nRealicemos un par de observaciones sobre la función elegida como ejemplo. En \nprimer lugar, nótese que la asignación del cuerpo del bucle (setq lista (cons \n(aref v i) lista)) modifica la ligadura local de lista creada en el let y no \notra global que pudiese existir. Como muestra el ejemplo, no es correcto identificar \nlet con variables locales y setq con variables globales, puesto que setq lo que \nmodifica es el valor del símbolo en el contexto activo (que puede ser local o global) y \nno en el contexto global. Por otra parte, al utilizar para ir ampliando la lista la \nprimitiva cons resultará que los elementos aparecerán en la lista en orden inverso a \ncomo aparecieran en el vector. Si deseamos mantener el orden de aparición de los \nelementos, podríamos utilizar en el cuerpo de la cláusula de parada la primitiva \nreverse, que es una función que invierte los elementos de una lista. \nUtilizando el hecho de que el do puede tratar con más de una variable en la lista que \nes su primer argumento, podemos escribir una versión diferente de la anterior \nfunción en la que no aparece let y el cuerpo del do no contiene ningún objeto Lisp: \n \n> (defun vector-a-lista (v n) \n \n   (do ((i 0 (+ i 1)) \n \n       (lista (list ) (cons (aref v i) lista))  ) \n \n     ((= i n) (reverse lista)))) \nObsérvese que si esta versión es correcta es debido a que todos los objetos de \nactualización son evaluados uno tras otro antes de realizar las nuevas ligaduras. \nNótese también que hemos utilizado la primitiva reverse descrita más arriba. \nTerminamos este apartado con una serie de procedimientos de entrada/salida y \notras primitivas que serán utilizadas en el programa cuyo texto aparece en el \napartado siguiente. \nVamos a introducirlas por medio de un procedimiento que, a partir de un símbolo \nleído desde el teclado, imprime otros símbolos en la pantalla. Se trata de un \nprocedimiento que simplemente procesa un objeto Lisp leído desde el teclado. \nObsérvese que no tiene argumentos. Pueden definirse tales subalgoritmos cuando \nlas entradas van a ser leídas por el teclado, si se usan variables globales o cuando \nla parametrización depende de las funciones o procedimientos a los que se llame \ndesde su cuerpo. A continuación encontramos la primitiva de escritura en pantalla \nformat. Se trata de un procedimiento que tiene al menos dos argumentos. Si el \n",
  "speaker": "SYSTEM",
  "uuid": "00635ece-ec48-413a-aadc-1a9e45ebe98e"
}