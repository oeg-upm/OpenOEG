{
  "message": "SYSTEM: Eswc2010webofdatatrack_submission_2.pdf: PÃ¡gina 8\n \nFigure 2: Generated LQP from our sample query \nSPARQL-D Query Optimizer. The SPARQL-D query optimizer receives the \nprevious LQP and generates an optimized query plan. As we described in the \nbackground section, the majority of optimizers are based on relational database \ninformation, such as the schema of the underlying database or the estimated number \nof tuples that the query will retrieve. In RDF datasets the schema can be always \nconsidered conceptually the same (subject, predicate and object), although different \nimplementations have varying schemas. Therefore, optimization-wise it is more \nimportant to know how many properties of a certain type exist between subjects and \nobjects, or the number of instances of certain concepts. This helps determining the \ncost of a specific SPARQL query, which can be measured as the estimated number of \nRDF triples that will be retrieved from each of the RDF datasets to be accessed. \nAnother consideration related to the number of triples retrieved from each RDF \ndataset is the cost of joining them. In this case it is possible to apply cost based \nalgorithms and other SQL optimizations, since the operators are the same. Real or \nestimated cost plans that select the operators with the minimal cost will be applied.  \nIn our approach we apply some of the default optimizations available in our \nunderlying query infrastructure: OGSA-DQP. These are heuristic based optimisations, \ncost based optimizations (using two step optimizations and mixing them with other \ncost-based optimizations) and those based on pushing the select clauses as next to the \ndata sources as possible.  \nBesides, we add a new optimizer: the RDFTableScanImplosion optimizer. As \naforementioned, SPARQL-D queries are translated into LQPs, which represent the \n",
  "speaker": "SYSTEM",
  "uuid": "ce243c1e-2862-4e36-b2d6-926b072b6843"
}