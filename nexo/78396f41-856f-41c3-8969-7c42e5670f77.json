{
  "message": "SYSTEM: StreamingDataAccess_ISWC2010.pdf: Página 10\none. The query has three atoms: WindSpeedMeasurement(x), measuredBy(x, y),\nand WindSensor(y).\nConcerning the formal deﬁnition of the query answering, let I = (∆I, \u0005I) be\nan interpretation, where ∆I is the interpretation domain and \u0005I the interpreta-\ntion function that assigns an element of ∆I to each constant, a subset of ∆I to\neach class and a subset of ∆I × ∆I to each property of the ontology. Given a\nquery q(x) ←ϕ(x, y) the answer to q is the set of tuples qI\nx ∈∆I × · · · × ∆I\nthat substituted to x, make the formula ∃y.ϕ(x, y) true in I [20,21]. Now we can\nintroduce the deﬁnition of the mappings. Let M be a set of mapping assertions\nof the form:\nΨ ; Φ\nwhere Ψ is a conjunctive query over the global ontology O, formed by terms of\nthe form C(x), R(x, y), A(x, z), with C, R, and A being classes, object properties\nand datatype properties respectively in O; x, y being object instance variables,\nand z being a datatype variable. Φ is a set of expressions that can be translated\nto queries in the target continuous language (e.g. sneeql) over the sources.\nA mapping assertion C(f Id\nC (x)) ; ΦS1,...,Sn(x) describes how to construct\nthe concept C from the source streams (or relations) S1, . . . , Sn. The function\nf Id\nC creates an instance of the class C, given the tuple x of variables returned\nby the Φ expression. More speciﬁcally this function will construct the instance\nidentiﬁer (uri) from a set of attributes from the streams and relations. In this\ncase the expression Φ has a declarative representation of the form:\nΦS1,...,Sn(x) = ∃y.pP roj\nS1,...,Sn(x) ∧pJoin\nS1,...,Sn(v) ∧pSel\nS1,...,Sn(v)\nwhere v is a tuple of variables in either x, y. The term pJoin denotes a set of join\nconditions over the streams and relations Si. Similarly the term pSel represents a\nset of condition predicates over the variables v in the streams Si (e.g. conditions\nusing <, ≤, ≥, >, = operators).\nA mapping assertion R(f Id\nC1(x1), f Id\nC2(x2)) ; ΦS1,...,Sn(x1, x2) describes how\nto construct instances of the object property R from the source streams and\nrelations Si. The declarative form of Φ is:\nΦS1,...,Sn(x1, x2) = ∃y.ΦS1,...,Sk(x1) ∧ΦSk+1,...,Sn(x2) ∧pJoin\nS1,...,Sn(v)\nwhere ΦS1,...,Sk, ΦSk+1,...,Sn describe how to extract instances of C1 and C2 from\nthe streams S1, . . . , Sk and Sk+1, . . . , Sn respectively. The term pJoin is the set\nof predicates that denotes the join between the streams and relations S1, . . . , Sn.\nFinally an expression A(f Id\nC (x), f T rf\nA\n(z)) ; ΦS1,...,Sn(x, z) describes how to\nconstruct instances of the datatype property A from the source streams and\nrelations S1, . . . , Sn. The function f T rf\nA\nexecutes any transformation over the\ntuple of variables z to obtain the property value (e.g. arithmetic operations, or\nstring operations). The declarative form of Φ in this case is:\nΦS1,...,Sn(x, z) = ∃y.ΦS1,...,Sk(x) ∧ΦSk+1,...,Sn(z) ∧pJoin\nS1,...,Sn(v)\n10\n",
  "speaker": "SYSTEM",
  "uuid": "78396f41-856f-41c3-8969-7c42e5670f77"
}