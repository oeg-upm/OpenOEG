{
  "message": "SYSTEM: The_Return_of_the_Entity-Relationship_Model_-_Ontological_Query_Answering.pdf: Página 9\n1 The Return of the Entity-Relationship Model: Ontological Query Answering\n9\n1.2.5 The Chase Procedure\nThe chase procedure (or simply chase) is a fundamental algorithmic tool introduced\nfor checking implication of dependencies [7], and later for checking query contain-\nment [8]. The chase is a process of repairing a database with respect to a set of de-\npendencies so that the resulting instance satisﬁes the dependencies. We shall use the\nterm chase interchangeably for both the procedure and its result. The chase works\non an instance through the so-called TGD and KD chase rules.\nTGD Chase Rule. Consider an instance I for a schema R, and a TGD σ =\nϕ(X,Y) →∃Zψ(X,Z) over R. If σ is applicable to I, i.e., there exists a homo-\nmorphism h such that h(ϕ(X,Y)) ⊆I, then: (i) deﬁne h′ ⊇h such that h′(Zi) = zi\nfor each Zi ∈Z, where zi ∈ΓN is a “fresh” labeled null not introduced before, and\nfollowing lexicographically all those introduced so far, and (ii) add to I the set of\natoms in h′(ψ(X,Z)), if not already in I.\nKD Chase Rule. Consider an instance I for a schema R, and a KD κ of the\nform key(r) = A over R. If κ is applicable to I, i.e., there are two (distinct) tuples\nt1,t2 ∈r(I) such that t1[A] = t2[A], then (i) if there exists i ̸∈A such that both t1[i]\nand t2[i] are constants of Γ , then there is a hard violation of κ and the chase fails,\notherwise (ii) for each i ̸∈A, either replace each occurrence of t1[i] with t2[i], if the\nformer follows lexicographically the latter, or vice-versa otherwise.\nGiven a database D for a schema R and set Σ = ΣT ∪ΣK over R, where ΣT are\nTGDs and ΣK are KDs, the chase algorithm for D with respect to Σ consists of an ex-\nhaustive application of the chase rules, which leads to a (possibly inﬁnite) instance,\ndenoted as chase(D,Σ). In particular, chase(D,Σ) is the instance constructed by\napplying (i) the TGD chase rule once, and (ii) the KD chase rule as long as it is\napplicable (i.e., until a ﬁxpoint is reached). We assume that the chase algorithm is\nfair, i.e., each TGD that must be applied during the construction of chase(D,Σ) is\neventually applied. We denote as chase[k](D,Σ) the initial segment of the chase of D\nwith respect to Σ obtained by applying k times the (TGD or KD) chase rule during\nthe construction of the chase.\nExample 1.1. Let R = {r,s}. Consider the set Σ of TGDs and KDs over R con-\nstituted by the TGDs σ1 = r(X,Y) →∃Z r(Z,X),s(Z) and σ2 = r(X,Y) →r(Y,X),\nand the KD κ of the form key(r) = {2}. Let D = {r(a,b)}. During the construction\nof chase(D,Σ) we ﬁrst apply σ1, and we add the atoms r(z1,a),s(z1), where z1 is a\n“fresh” null of ΓN. Moreover, σ2 is applicable and we add the atom r(b,a). Now, the\nKD κ is applicable and we replace each occurrence of z1 with the constant b; thus,\nwe get the atom s(b).\nThe fairness assumption allows us to show that the chase of D with respect to Σ is\na universal model of D with respect to Σ, i.e., for each I ∈mods(D,Σ), there exists a\nhomomorphism from chase(D,Σ) to I (see, e.g., [23, 24]). Thus, the answer to a CQ\nq with respect to D and Σ, if the chase does not fail, can be obtained by evaluating\nq over chase(D,Σ), and discarding tuples containing at least one null [23]. If the\nchase fails, then mods(D,Σ) = ∅and ans(q,D,Σ) = Γ n.\n",
  "speaker": "SYSTEM",
  "uuid": "0f9497cc-6133-47f5-9f51-75a622d11f2a"
}