{
  "message": "SYSTEM: BUSQUEDA.pdf: Página 13\nBÚSQUEDA \n \n13 \nJ. Rubio / P.R. Muro / J. Bañares \n \nOctubre 2004 - Curso 2004-2005 \ndel primer argumento es nil (la lista vacía), el segundo argumento no será \nevaluado, pero sí lo será el tercero (la rama \"si no\"), cuyo valor será el del if. \nEsto nos permite programar una función que calcule el máximo de dos números \nenteros: \n \n> (defun mayor (x1 x2)  \n \n \n; x1 y x2 deberán ser números enteros \n \n \n(if (< x1 x2) \n \n \n \nx2 \n \n \n \nx1)) \n \n===> MAYOR \n \n> (mayor 2 3) ===> 3 \n \n> (mayor (* 2 7)  3) \n===> 14 \n \n> (mayor 6 'numero) ===> ¡¡¡¡ ERROR !!!! \nEn Lisp los comentarios (aquellas partes del texto que no serán tomadas en \nconsideración por el evaluador) se indican mediante ;, el punto y coma. Cuando \naparece en una línea el carácter reservado ; se entiende que el texto que aparece \ntras él en esa línea es un comentario. En el ejemplo anterior se ha escrito como \ncomentario la especificación de entrada de la función de mayor: si sus argumentos \n(definitivos) no son números enteros su comportamiento está indefinido. En \nparticular, si se introduce un símbolo como argumento (como en la última línea del \nejemplo) se producirá un error. \nCon estos pocos preliminares, podemos ya escribir programas que realicen cálculos \nrepetitivos. Para ello nos apoyamos en la recursividad, que en Lisp puede ser \ncomprendida sin más que aplicar las reglas generales de evaluación explicadas más \narriba. Por ejemplo, la siguiente función permite calcular el factorial de un número \nentero positivo: \n \n> (defun factorial (n)  \n \n \n; n deberá ser un número entero positivo \n \n \n(if (= n 0) \n \n \n \n1 \n \n \n \n(* n (factorial (- n 1))))) \n===> FACTORIAL \n \n> (factorial 4) \n \n===> 24 \nPara terminar esta brevísima introducción a la programación en Common Lisp, \nvamos a mostrar cómo las listas pueden ser empleadas como estructuras de datos \n",
  "speaker": "SYSTEM",
  "uuid": "0ab11706-e1d2-4617-a0be-6af1d21b28df"
}