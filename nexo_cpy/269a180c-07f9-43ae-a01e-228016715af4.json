{
  "message": "SYSTEM: OntologyDebugging_KCAP2009.pdf: Página 5\nFinding appropriate recommendations at each step in the \nprocess may be a hard task, even for experienced ontology \ndevelopers. Thus we also propose a more detailed strategy \nto be followed for obtaining recommendations, based on the \ncatalogue of anti-patterns described in section 2. We pro-\npose to follow a specific order, based on our experience, as \nsummarised in Figure 2. \nFirst, we recommend solving terminological problems \n(SOE), checking the use of equivalence and disjoint con-\nstructors between classes (EID, DOC) and applying the \nguideline GA in order to make formal definitions easier to \nunderstand, grouping in the same definition all the axioms \ndealing with the same role. These are the easiest anti-\npatterns to detect and they are useful to clean other ontol-\nogy definitions. \nThen we propose checking the root unsatisfiable concepts \nin the ontology, using any off-the-shelf debugging tool \n(e.g., the justification system of Protégé). At that point the \nontology developer can check the use of universal restric-\ntions (OIL), existential restrictions (AIO, SOS, DCC) and \ntheir combinations (UE). Sometimes, inconsistencies arise \nfrom a combination of several anti-patterns, so that is the \nreason why there are loops in the figure.  \nAfter solving problems in root unsatisfiable classes, reason-\ners have to be used again to go down in the concept hierar-\nchy, and apply iteratively the same steps, except for the \ncase of patterns like OILWI and UEWI, where the process \nis from leaves to the root classes. \nIn the end we propose removing superfluous axioms to im-\nprove the clarity of the ontology (SMALO, MIZ) \n3.2 Recommendations for Individual Anti-\nPatterns \nIn this section, for each anti-pattern we provide one or sev-\neral recommendations that can be followed by ontology \ndevelopers in order to remove inconsistencies (in the case \nof logical anti-patterns) or to improve the ontology structure \n(for NLAP and Guidelines).  \n3.2.1 \nRecommendations for Logical Anti-patterns \nAntiPattern AIO \nC1⊆ ∃R.(C2∩C3), disj(C2,C3) =>  \n     #1 C1⊆∃R.(C2∪C3) \n     #2 C1⊆∃R.C2∩∃R.C3 \nReplace the logical conjunction by the logical disjunction, \nor by the conjunction of two existential restrictions, which \nwill lead into another non-logical anti-pattern.  \nAntiPattern OIL \nC1⊆∀R.C2, C1⊆∀R.C3,disj(C2,C3) => C1⊆∀R.(C2∪C3) \nIf it makes sense, the two universal restrictions could be \ntransformed into only one that refers to the disjunction of \nC2 and C3.  \nAntiPattern OILWI \nC1⊆C2, C1⊆∀R.C3, C2⊆∀R.C4, disj(C3,C4) => \n     C2⊆∀R.(C3∪C4) \nIf it makes sense, add the universal restriction of C1 to C2, \nusing a class disjunction. As described in section 3.1, the \nstrategy to be followed for correcting these antipatterns is to \nstart from the leaves of the class hierarchy and check the \nparent class axiom dealing with the same role R. Normally, \nin case that the ontology developer wants to keep the parent \ndefinition, a new class (C2’) has to be added with the parent \ndefinition as a sibling class of C1. By adding a new class, \nFigure 2: Detailed debugging strategy based on antipatterns  \n",
  "speaker": "SYSTEM",
  "uuid": "269a180c-07f9-43ae-a01e-228016715af4"
}