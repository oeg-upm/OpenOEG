{
  "message": "SYSTEM: Wiki: https://delicias.dia.fi.upm.es/wiki/index.php/Dong_et_al-data_integration_uncertainty \n\nUncertainty in data integration\nsometimes it is impossible to create precise mappings\nusers are not skilled enought to provide the mapping\nusers do not know the domain well and so do not know what the correct mappings are\nthe scale of the data prevents generating and maintaining precise mappings\nuncertain data\ndata extracted from semi-structure sources by automatic methods\ndata comes from unreliable sources or not uptodate\nuncertain queries\nqueries posed as keywords\nsystem needs translated into structured queries\nmultiple candidate queries can be generated and it is uncertain which one is the real intent of the user\nProbabilistic Schema Mappings\nhave a probability associated with it\ntwo possible interpretations:\nby-table semantics\nassumes that one single mapping between the source and the target exists, but we don't know which one it is.\nby-tuple semantics\nthe correct mapping depends on the particular tuple in the source\nfor both cases query anwerins are a generalization of certain answers\nProposed Architecture\nsystem is based on probabistic data model\nprobabilities are attached to each tuple, mappings, and answers\nthese probabilities are mostly internal and not exposed to users\nprobabilities are used to rank answers\nreformulate keyword queries into a set of candidate structured queries\ndoes not assume access to all the data in the source\ndoes not assume source supports keyword searching\nit tries to identify structural elements in the query\ne.g. \"chicago weather\" it recognices that \"weather\" is an attribute and \"chicago\" is an instance.\nadaptive query processing\nsupports top-k answers\nit uses a middle layer to decide at runtime which queries are critical to computing the top-k answers\nthere can be mutiple interations of deciding the promising reformulated queries and retrieving answers\nthe system can even decide which data sources are more relevant a prioritize\nafter receiving answers from different data soures, the system combines them to get a single set of answers\nHandling Uncertainty in Mappings\nmultiples mappings with different probabilities\nqueries are formulated for every mapping.\nfinal answers are assigned probabilities using an aggregation function\nin the case of computing the top-k answers the system can stop querying after the determining that more queries will no produce answers with higher probabilites\nSemantics of probabilistic schema mappings\nnon-probabilistic GLAV mapping: m : ∀x(φ(x) → ∃yψ(x, y))\nφ is the body of a conjunctive query over the source schema\nψ is the body of a conjunctive query over the target schema\na pair of instances Ds (source instance) and Dt (target instance) satifies m if for every assignment of x in Ds that satisfies φ there is a y in Dt that satisfy ψ\nthe authors consider a limited from of GLAV mappings where:\nφ (resp. ψ) is an atomic formula over S (resp. T)\nthe mapping does not include constants\neach variable occurs at most once on each side if the mapping.\nthis restricted mapping can be defined as attribute correspondences.\nformally a relation mapping M is a triple (S, T, m) where S is a source relation, T is a target relation and m is a set of attribute correspondences\nwhen each source and target attribute occur in at most one correspondence in m, M is one-to-one relation mapping\na schema mapping is a set of one-to-one relation mappings where every source and targe relation appear at most once.\na probabilistic mapping (p-mapping) pM is a triple  (S,T,m) where m is a set {(m1,Pr(m1)), ... ,(ml,Pr(ml))} such that:\nfor i in [1,l], mi is a one-to-one mapping between S and T, and for every i,j in [1,l], i =/= j => mi =/= mj\nPr(mi) in [0,1] and Sum([1..l], Pr(mi)) = 1\na schema p-mapping is a set of p-mappings between source and targe relations where every source and targe relation appear at most once.\ntwo possible interpretaions of uncetainty in a schema mapping\n1) a single mapping in pM is the correct one and it applies to all the data in S (by-table semantics)\n2) multiple mappings are correct and each suitable for a subset of tuples in S, though it is unknown which mapping is the right one for a scpecifict tuple. (by-tuple semantics)\nBy-table consistent instance:\nLet pM = (S,T,m) be a p-mapping and Ds be an instance of S\nAn instance Dt of T is said to be by-table consistent with Ds and pM is there's a mapping m such that Ds and Dt satisfy m\nTarm(Ds) is the, possible infinite, set of of all constisten intances\nBy-table answer:\nLet pM = (S,T,m) be a p-mapping. Let Q be a query over T and let Ds be and instance of S\nLet t be a tuple. Let m(t) ve the subset of m, such that for each m in m(t) and for each Dt in Tarm(Ds), t is in Q(Dt)\nLet p = Sum(m in m(t), Pr(m)) if p > 0 then (t,p) is a by-table answer of Q with respect to Ds and pM.\nBy-tuple consistent instance:\nLet pM = (S,T,m)  be a p-mapping and let Ds be an instance of S with d tuples.\nAn instance Dt of T is by-tuple consistent with Ds and pM, if there is a sequence <m1, ..., md> such that for every 1 < i < d,\nmi in m\nfor the ith tuple of Ds, ti, there exists a target tuple t'i in Dt such that ti and t'i satisfy mi\nGiven seq = <m1,...,md> , Tar_seq(Ds) is the set of all target instances that are consistent with Ds and seq.\nWe can think of every sequence of mappings seq = <m1, ..., md> as a separete event whose probability is Pr(seq) = Multi(i in [1..d], Pr(mi))\nif there are l mappings in pM, then there are l^d sequences of length d and their probabilities add up to 1\nseq_d(pM) is the set of mapping sequences of length d generated from pM\nBy-tuple Answer:\nLet pM = (S,T,m) be a p-mapping, let Q be a query over T and Ds an instance of S with d tuples\nLet t be a tuple\nLet seq(t) be the subset of seq_d(pM), such that for each seq in seq(t) and for each Dt in Tar_seq(Ds), t in Q(Dt)\nLet p = Sum(seq in seq(t), Pr(seq)). if p > 0 , we call (t,p) a by-tuple answer of Q with respect to Ds and pM\nBy-table query answering algorithm\nCompute the certain answers of Q under each of the mappings m.\nAttach the probability of Pr(m) to every centain answer under m\nif a tuple is an answer under mutiple mappings then add the probabilites\nboth steps of the algorithm can expressed as SQL queries with grouping and aggregation\nwith the restricted form of schema mappings the algorith takes P-time in the size of the data and mappings.\ngenral GLAV mappings can also be supported and stay between the P-time boundry\nBy-tuple query answering algorithm\nwe need to compute the certain answers for every mapping sequence generated by pM\nthe number of such mapping sequences is exponential in the size of the input data\nthis exponential time complexity is not avoidable\nanswering SPJ queries by-tuple semantics is hard\nthe high complexity comes from computing the probability of the answers\nknowing just what are the possible answers can be done in P-time\nthe extension of tuple-semantics to general GLAV mappings is complex and left for future work\ntwo classes of queries are identified where by-tuple query answering is polynomial\nNon-p-join queries\nProjectted p-join queries\nTOP-K query answering\nthe basic idea is to maintain the upper bound pmax(t) and the lower bound pmin(t) of each tuple t.\nthe algorithm terminates when we find k tuples whose pmin values are higher than pmax of the rest of the tuples\nthe algorithm is also presented for answering non-p-join queries with tuple-semantics\nP-Mapping represeantion\nGroup probabilistic Mapping\na n-group p-mapping gpM is a triple (S,T,pM), where\n{S1,..,Sn}, {T1,...,Tn} are sets of disjoint subsets of attributes in S and T\npM is a set of m-mappings {pM1,..,pMn}, where for each 1 <= i <= n, pMi is a p-mapping between Si and Ti\nthe semantics of an n-group p-mapping gpM is a p-mapping that includes the Cartesian product of the mappings in each of the pMi's.\nthe probability of the mapping composed of m1 in pM1, ... mn in pMn is Multi(i in [1..n], Pr(mi))\nProbabilistic Correspondences\nthe p-mapping is (S,T,c)\nc is the set {(cij,Pr(cij)| i in [1..m], j in [1..n], cij is an attribute correspondence, and Pr(cij) in [0,1]}\nfor each i oin [1..m], Sum(j in [1..n], Pr(cij) <= 1)\nfor each j oin [1..n], Sum(i in [1..m], Pr(cij) <= 1)\nBayes-Net",
  "speaker": "SYSTEM",
  "uuid": "3a21ebc1-7d7c-4e9d-9ea7-5f01dec6965f"
}