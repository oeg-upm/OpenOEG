{
  "message": "SYSTEM: BUSQUEDA.pdf: Página 32\nBÚSQUEDA \n \n32 \nJ. Rubio / P.R. Muro / J. Bañares \n \nOctubre 2004 - Curso 2004-2005 \nAhora el nivel físico de representación consiste en elegir una estructura de datos \npara los estados e implementar utilizándola cada una de esas funciones (las dos \núltimas pueden ser en realidad procedimientos funcionales). \nPor ejemplo, si decidimos representar las garrafas por medio de registros \npodríamos definir:  \n \n> (defstruct garrafas tres cuatro)  \n===> GARRAFAS \ny  \n \n> (defun  construye-garrafas (x y) \n \n \n(make-garrafas :cuatro x :tres y))  \n \n \n===>  \nCONSTRUYE-GARRAFAS \n \n \n> (defun  modifica-garrafa4 (garrafas n)  \n \n \n(setf (garrafas-cuatro garrafas) n) \n \n \ngarrafas)  \n \n \n \n \n===> MODIFICA-GARRAFA4 \nEn la última operación hemos utilizado que en el cuerpo de un defun puede \naparecer cualquier secuencia de elementos Lisp, que serán evaluados uno tras otro \ny el valor resultado de la última evaluación será el devuelto por la llamada a la \nfunción (se trata de un bloque implícito; es lo que se denomina en la terminología \nLisp un progn implícito). Obsérvese que la secuencia no está encerrada en \nparéntesis adicionales. De hecho, sería un error escribir en el cuerpo de la anterior \nfunción: \n \n ((setf (garrafas-cuatro garrafas) n) \n \n \ngarrafas) \n¿Por qué? \nEjercicios. \n1) Completar la implementación de las operaciones con esa representación. \n2) Utilizar una representación con vectores (de dos elementos) e implementar en \nella las operaciones. \nNo es difícil repetir el proceso anterior para una representación de las garrafas \ncomo listas. La única complicación reside en que si queremos interpretar los \noperadores de modificación en un sentido estricto (es decir, de modo que su \nparámetro sea efectivamente modificado y no solamente utilizado para construir un \n",
  "speaker": "SYSTEM",
  "uuid": "945a4d42-184d-407c-9c85-acad948fdef9"
}