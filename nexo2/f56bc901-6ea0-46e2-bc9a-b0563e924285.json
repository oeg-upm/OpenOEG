{
  "message": "SYSTEM: BUSQUEDA.pdf: Página 53\nBÚSQUEDA \n \n53 \nJ. Rubio / P.R. Muro / J. Bañares \n \nOctubre 2004 - Curso 2004-2005 \nsimilar a equal, pero que es más eficaz si lo que queremos es comparar la igualdad \nde un símbolo con otro objeto Lisp (este es el caso en el ejemplo). Este if tiene dos \nramas que son sendos progn. Esta es una de las escasas estructuras Lisp en las \nque es normal encontrar un progn explícito: if no puede tener más de tres \nargumentos. \nEn la rama \"entonces\" de ese condicional, pedimos una confirmación de si se desea \nterminar la evaluación. Empleamos para ello la primitiva y-or-n-p que es un \npredicado que lee del teclado un carácter. Si la tecla pulsada ha sido y devuelve t, \nsi n devuelve nil y en cualquier otro caso vuelve a solicitar un carácter. Si \nintroducimos n, la rama \"si no\" vuelve a llamar recursivamente a pregunta. Si \nintroducimos y, la rama \"si no\" se encarga de finalizar la evaluación. La primitiva \nread-char es como read salvo que lee un carácter en lugar de un símbolo, \nnúmero o lista. En el ejemplo, se pide que se pulse la barra espaciadora para evitar \nel \"eco\" del carácter tecleado, pero con cualquier otra tecla la evaluación también \nterminaría. Por último, aparece una llamada, sin ningún argumento, a la primitiva \nvalues. Esto es hecho para evitar que el carácter pulsado vuelva a aparecer en la \npantalla, puesto que (values) … no devuelve ningún valor. Se usa cuando \nqueremos que un subalgoritmo sea realmente un procedimiento (es decir, que no \ndevuelva ningún valor) y habitualmente con operaciones de salida en las que no \nqueremos que la parte de escritura del bucle de lectura-evaluación-escritura añada \nnada en la pantalla. En particular, puede ser interesante usarlo tras un (format t \n…) para evitar que el valor devuelto nil aparezca en pantalla. \nLa rama \"si no\" de (if (eq entrada 'fin) …) es la que realmente procesa la \nentrada. Se trata en esencia de un condicional (case) tras el que se vuelve a llamar \nrecursivamente a pregunta. El primer argumento para el elemento especial case \nes un elemento Lisp que será evaluado. Su valor será empleado para compararlo \ncon las claves que aparecen en las cláusulas case. El formato de una cláusula \ncase es: una lista cuyo primer elemento es la clave, que no será evaluada (por ello \nes conveniente que las claves de los case sean símbolos) y a continuación tenemos \nel cuerpo de la cláusula, que será un progn implícito. El valor obtenido por \nevaluación \ndel \nprimer \nargumento \nde \ncase \nserá \ncomparado \n(con \neq) \nsecuencialmente con cada una de las claves. Si es igual a alguna de ellas, se \nprocederá a evaluar el cuerpo de esa cláusula y el valor devuelto (por el progn \nimplícito) será el valor del case, terminando la evaluación del case (es similar al \ncase de Pascal y diferente del switch de C). Si no hay igualdad con ninguna clave, \nel case devolverá nil. Para evitar esta situación se puede utilizar la clave \n",
  "speaker": "SYSTEM",
  "uuid": "f56bc901-6ea0-46e2-bc9a-b0563e924285"
}