{
  "message": "SYSTEM: BUSQUEDA.pdf: Página 99\nBÚSQUEDA \n \n99 \nJ. Rubio / P.R. Muro / J. Bañares \n \nOctubre 2004 - Curso 2004-2005 \n(defun padre-de-nodo (nodo)  \n  (nodo-padre nodo)) \n \n(defun g-de-nodo (nodo)  \n  (nodo-g nodo)) \n \n(defun h-de-nodo (nodo) \n  (nodo-h nodo)) \n \n \n(defun ubicacion-de-nodo (nodo) \n  (nodo-ubicacion nodo)) \n \n(defun modifica-padre (nodo nuevo-padre) \n  (setf (nodo-padre nodo) nuevo-padre)) \n \n(defun modifica-g (nodo nuevo-g) \n  (setf (nodo-g nodo) nuevo-g)) \n \n(defun modifica-ubicacion (nodo nueva-ubicacion) \n  (setf (nodo-ubicacion nodo) nueva-ubicacion)) \n \n; Crea el nodo inicial (las funciones estado-inicial  \n; y funcion-heuristica dependen del problema a resolver): \n \n(defun crea-nodo-inicial () \n  (let ((estado-inicial (estado-inicial))) \n    (crea-nodo estado-inicial  ; estado \n               NIL             ; padre \n               0               ; g \n               (funcion-heuristica estado-inicial)  ; h \n               'ABIERTOS)))    ; ubicacion \n \n; Selecciona elige el nodo de menor valor f = g + h de entre los \n; que estan en ABIERTOS; si no hay ninguno se devuelve NIL (lo que \n; hace que en ocasiones el-nodo no sea tal, pero facilita el control \n; del bucle). \n \n(defun selecciona (lista-nodos) \n  (do ((nodos lista-nodos (rest nodos)) \n       (el-nodo NIL)) \n      ((endp nodos) el-nodo) \n    (let ((nodo (first nodos))) \n      (if (eq 'ABIERTOS (ubicacion-de-nodo nodo)) \n          (if (or (eq el-nodo NIL) \n                  (< (+ (g-de-nodo nodo) (h-de-nodo nodo)) \n                     (+ (g-de-nodo el-nodo) (h-de-nodo el-nodo)))) \n              (setq el-nodo nodo)))))) \n \n; Expansion de un nodo (funciones que dependen del problema: expandir-estado, \n; coste-arista, estados-iguales?) \n \n(defun expandir-nodo (nodo lista-nodos) \n  (let ((estado (estado-de-nodo nodo)) \n        (lista-nuevos-nodos (list ))) \n    (do ((estados (expandir-estado estado) (rest estados))) \n        ((endp estados) lista-nuevos-nodos) \n      (let ((estado-nuevo (first estados))) \n        (let ((nodo-viejo (encuentra estado-nuevo lista-nodos)) \n              (coste-auxiliar (+ (coste-arista estado estado-nuevo) \n                                 (g-de-nodo nodo)))) \n          (if (eq nodo-viejo NIL) \n              (setq lista-nuevos-nodos \n                    (cons (crea-nodo estado-nuevo     ; estado \n                                     nodo             ; padre \n                                     coste-auxiliar   ; g \n                                     (funcion-heuristica estado-nuevo) ; h \n                                     'ABIERTOS)       ; ubicacion \n                          lista-nuevos-nodos)) \n             (if (< coste-auxiliar (g-de-nodo nodo-viejo)) \n                 (progn (modifica-padre nodo-viejo nodo) \n                        (modifica-g nodo-viejo coste-auxiliar) \n                        (modifica-ubicacion nodo-viejo 'ABIERTOS))))))))) \n",
  "speaker": "SYSTEM",
  "uuid": "d5f0343f-85cc-4fc1-9122-705f577a00fd"
}