{
  "message": "SYSTEM: BUSQUEDA.pdf: Página 73\nBÚSQUEDA \n \n73 \nJ. Rubio / P.R. Muro / J. Bañares \n \nOctubre 2004 - Curso 2004-2005 \ninicial. Otra idea análoga sería almacenar los operadores que han producido el \nestado del nodo a partir del estado inicial y contar su número. Estas dos \nposibilidades conllevan un coste en tiempo de ejecución cada vez que se llama a \nprofundidad-de-nodo. Otra solución que no requiere tiempo de ejecución, pero \nque conlleva una necesidad mayor de memoria, consiste en almacenar en cada \nnodo explícitamente (por medio de un campo, por ejemplo) su nivel de profundidad. \nPor último, la solución más económica en tiempo y en espacio consiste en mantener \nen una variable global la profundidad en que nos encontramos en cada momento del \nproceso de búsqueda. Su inconveniente es que es necesario señalar de algún modo \ncuando hemos cambiado de nivel. La forma más natural de hacerlo es incluyendo \nalgun tipo de marcas (elementos que no son nodos) en la lista ABIERTOS, lo que no \nes excesivamente elegante desde el punto de vista de la programación (ABIERTOS \ndeja de ser una lista de nodos para convertirse en algo más general y de \ninterpretación más difícil). Obsérvese que no es conveniente (aunque es mucho más \nclaro) el almacenar el cambio de nivel (si existe) en los nodos, pues ello requeriría \nun coste en espacio equivalente al almacenaje explícito del nivel de profundidad. \nEjercicios. \n1) Impleméntese la búsqueda con límite de profundidad. Utilícese una función \ngenérica (defun profundidad-de-nodo (nodo) …). Será necesario cambiar \nexpandir-nodo. \n2) Impleméntese la función (defun profundidad-de-nodo (nodo) …) de \ndos modos distintos: (a) calculando la longitud del camino al nodo inicial (lo que, en \ngeneral, requiere información sobre el \"padre\" en cada nodo); (b) con un campo \nexplícito para almacenar la profundidad (en este segundo caso será necesario \nalterar de nuevo expandir-nodo). \n3) Verificar como funcionan las correspondientes búsquedas en el problema de \nlas garrafas. \nComo ya hemos señalado, la profundidad de la que se habla en la anterior variante \nes la profundidad en el árbol de búsqueda. Esto significa que si la variante es \naplicada al algoritmo de búsqueda en árbol y el espacio de estados es un grafo, \nnada nos asegura que un estado no va a ser examinado más de una vez \n(compruébese en el problema de las garrafas y, como se indicó más arriba, en el \nespacio de la figura 8). Por tanto, sigue teniendo sentido el trabajar con la versión en \ngrafo (variante del algoritmo de 3.5), aunque ahora sea sólo por economía y no por \nevitar los bucles infinitos. \n",
  "speaker": "SYSTEM",
  "uuid": "c5d808ad-4504-480b-93d7-0ffb6361624f"
}