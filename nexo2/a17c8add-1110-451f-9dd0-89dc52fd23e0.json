{
  "message": "SYSTEM: Eswc2010webofdatatrack_submission_2.pdf: Página 7\nWe will use throughout the rest of this section the following query about music \nbands and their members. The query asks DBPedia for those bands that were involved \nin (i.e., whose genre is) the Madchester movement, together with the current members \nthat they have, if any, according to the BBC SPARQL endpoint (which in fact \nreplicates a large part of the information from DBPedia, although this is not relevant \nfor the sake of presenting our approach). The query has two main parts: the first triple \npattern retrieves all the bands that were involved in the Madchester movement. The \nsecond triple pattern is optional, and asks for the current members of the band. The \nresults of both patterns are merged with a left outer join. Our SPARQL extensions are \nrepresented in bold font, including the datasets to access and the variables to bind \nfrom each of them. \n \nPREFIX p: <http://dbpedia.org/property/>  \nSELECT ?dbpedia.band ?bbc.member \nFROM dbpedia: <http://dbpedia.org/sparql>  \nFROM bbc: <http://api.talis.com/stores/bbc‐backstage/services/sparql> \nWHERE{ \n      ?dbpedia.band p:genre <http://dbpedia.org/resource/Madchester>.  \n      OPTIONAL {?dbpedia.band p:currentMembers ?bbc.member}} \n3.2 SPARQL-D Distributed Query Processor \nWe will now describe the characteristics of each of the components of our distributed \nquery processor, according to the set of components identified in Figure 1.  \nSPARQL-D parser. It is the module in charge of creating an Abstract Syntax Tree \n(AST) from the initial SPARQL-D query.  \nSPARQL-D Logical Query Plan (LQP) Builder. The SPARQL LQP builder \nreceives the previous AST as an input and generates an operator representing the \nSPARQL-D LQP (as shown in Figure 2). A SPARQL-D logical query plan is a \ndirected graph whose nodes are a mix of relational and SPARQL operators. The \nprocessing of the query is done in two stages: first we process the prologue section of \nthe SPARQL query, obtaining the SPARQL prefixes and the variables to be retrieved \nfrom the RDF repository, as specified in the FROM list; then we process the WHERE \nclause, considering two major blocks: graph-matching triples and OPTIONAL \nclauses. Solution modifiers like DISTINCT are also processed here. However, in our \ncurrent implementation we leave out FILTER clauses. \nThe processing of the WHERE clause is based on the equivalence between \nSPARQL and SQL described in [4]: any two triples are translated as equi-joins if they \nshare a variable, and OPTIONAL clauses are treated as SQL left outer joins. Besides, \nwe apply the well-designed pattern concept [13] to OPTIONAL clauses.  \nFor the special case of blank nodes and results without any value we assign the \nvalue “BlankNode” (which is adequately escaped in case that this specific string \nappears as a normal result of a query). Attributes that do not contain any value will \nhave this special value, so that it will be possible to make joins with them. Otherwise \nerrors and problems like the ones commented in the background section may arise. \n \n",
  "speaker": "SYSTEM",
  "uuid": "a17c8add-1110-451f-9dd0-89dc52fd23e0"
}