{
  "message": "SYSTEM: Wiki: Syntactic translation from SPARQL to ODMQL\nContents\n[\nhide\n]\n1\nWhich SPARQL queries can be expressed in ODMQL?\n2\nBasic Triple patterns\n3\nClass Expressions\n3.1\nObjectSomeValuesFrom\n3.2\nDataHasValue\n3.3\nNormalizations\n3.3.1\nSubsumption\n3.3.2\nEquivalence\n3.3.3\nIntersection\n4\nAggregation and Disjunction in Queries\n4.1\nUNION\n4.2\nOPTIONAL\n5\nFilters\n5.1\nConjunctions in Filters\n6\nConclusions\nWhich SPARQL queries can be expressed in ODMQL?\n\nODMQL allows the construction of ABox conjunctive queries. In other words, we can express queries which permit the retrieval of individuals which are member of a specified (restricted) class expression. ODMQL also allows the projection of property values. For these reasons we can only translate to ODMQL those SPARQL queries with at most on variable that bind to individuals, and zero or more variables that bind to values of properties of such individuals.\nOnly tree-shaped graph patterns can be translated to ODMQ, where the root of this tree is  a variable (not necessarily projected) that bind to individuals.\nBasic Triple patterns\n\n?x <rdf:type> <TYPE_URI> .\n<onConcept conceptUri=\"TYPE_URI\"/>\n?x <OBJECT_PROPERTY_URI> <INDIVIDUAL_URI> .\nThis is impossible to express in ODMQL since this language does not provide a constructor for restricting the value of an object property to a particular instance. In ODMQL the value of an object property can only be restricted by type.\n?x <DATA_PROPERTY_URI> \"LITERAL\" .\n<onConcept>\n   <attRestriction oper-id=\"=\" >\n      <onAtt attName=\"DATA_PROPERTY_URI\" />\n      <hasAttVal value=\"LITERAL\" />\n   </attRestriction>\n</onConcept>\n?x <rdf:type> ?c .\nThe specification of ODMQL does not make explicit if one can consider rdf:type as a property. At this point it is unknown if this pattern can be translated.\n?x <OBJECT_PROPERTY_URI> ?val .\n<onConcept>\n   <relSelect>\n      <onRel relName=\"OBJECT_PROPERTY_URI\" />\n   </relSelect>\n</onConcept>\n?x <DATA_PROPERTY_URI> ?val.\n<onConcept>\n   <attSelect>\n      <onAtt attName=\"DATA_PROPERTY_URI\" />\n   </attSelect>\n</onConcept>\nClass Expressions\n\nWe can express complex class expression in ODMQL with the following constructs:\nObjectSomeValuesFrom\nDataHasValue\nTo query the members of a class expression in SPARQL, the following triple patterns are used:\n?x <rdf:type> _:c .\n_:c <rdfs:subClassOf> _:r .\n_:r0 <rdf:type> <owl:Restriction> .\ntogether with triple patterns that define the restriction _:r.\nObjectSomeValuesFrom\n\n_:r <owl:onProperty> <OBJECT_PROPERTY_URI> .\n_:r <owl:someValuesFrom> _:c .\n<onConcept>\n   <relRestriction>\n      <onRel relName=\"OBJECT_PROPERTY_URI\" />\n      <hasRelVal>\n         ... TRANSLATION of patterns with _:c as subject ...\n      <hasRelVal>\n   <relRestriction>\n<onConcept>\nDataHasValue\n\n_:r <owl:onProperty> <DATA_PROPERTY_URI> .\n_:r <owl:hasValue> \"LITERAL\" .\n<onConcept>\n   <attRestriction oper-id=\"=\">\n      <onAtt attName=\"DATA_PROPERTY_URI\" />\n      <hasAttVal value=\"LITERAL\" />\n   <attRestriction>\n<onConcept>\nNote:\nthis translation is the same as that of the basic triple pattern ?x <DATA_PROPERTY_URI> \"LITERAL\". However, considering the explicit restriction translation is necessary as this one can appear nested inside an ObjectSomeValuesFrom restriction.\nNormalizations\n\nThe following class expressions can be normalized:\nSubsumption\n\n?x <rdf:type> _:c .\n_:c <rdfs:subClassOf> _:c2 .\nis converted to :\n?x <rdf:type> _:c .\n?x <rdf:type> _:c2 .\nEquivalence\n\n?x <rdf:type> _:c .\n_:c <owl:equivalentClass> _:c2 .\nEliminate the triple pattern _:c <owl:equivalentClass> _:c2 , and\nreplace all occurrences of _:c2 by _:c\n.\nIntersection\n\n?x <rdf:type> _:c .\n_:c <owl:intersectionOf> (_:c2 _:c3 ...) .\nis converted to :\n?x <rdf:type> _:c .\n?x <rdf:type> _:c2 .\n?x <rdf:type> _:c3 .\n...\nAggregation and Disjunction in Queries\n\nThe SPARQL language provides the UNION operator which allow matching two different graph patterns and then merge them together. There's also an OPTIONAL operator to indicate that a specified graph pattern can be optionally matched.\nUNION\n\nThe SPARQL's UNION operator cannot be translated directly into ODMQL. However, we can\ntread the UNION as two independent queries\nwhich and then be merged programmatically.\nOPTIONAL\n\nODMQL only allow conjunctive queries, therefore the disjunction implicit in the OPTIONAL operator cannot be translated into ODMQL.\nFilters\n\nFILTER expressions on\nnumerical literals\ncan be supported.\n?x <DATA_PROPERTY_URI> _:val .\nFILTER ( _:val OPERATOR LITERAL )\nWhere OPERATOR can be: '=' | '>' | '<'\n<onConcept>\n   <attRestriction oper-id=\"OPERATOR\" >\n      <onAtt attName=\"DATA_PROPERTY_URI\" />\n      <hasAttVal value=\"LITERAL\" />\n   </attRestriction>\n</onConcept>\nConjunctions in Filters\n\n?x <DATA_PROPERTY_URI> _:val .\nFILTER ( _:val OPERATOR_1 LITERAL_1 && _:val OPERATOR_2 LITERAL_2 && ... )\n<onConcept>\n   <attRestriction oper-id=\"OPERATOR_1\" >\n      <onAtt attName=\"DATA_PROPERTY_URI\" />\n      <hasAttVal value=\"LITERAL_1\" />\n   </attRestriction>\n   <attRestriction oper-id=\"OPERATOR_2\" >\n      <onAtt attName=\"DATA_PROPERTY_URI\" />\n      <hasAttVal value=\"LITERAL_2\" />\n   </attRestriction>\n   ...\n</onConcept>\nNote:\nthe value of the property (_:val) cannot be projected. This is why it is represented as a black node.\nConclusions\n\nI have presented some basic transformations from SPARQL to ODMQL. This indicates that it is possible to make direct translations from SPARQL to ODMQL. However, at a first look, the subset of SPARQL queries that can be supported seem rather limited. In my opinion, the most important limitation is that one cannot ask for those individuals that participate in a particular relation some other specific individual. In other words, we cannot ask a question of the following form:\n?x <chem:reactsWith> <chem:ethanol>\n--\nalex\n12:51, 13 November 2009 (CET)",
  "speaker": "SYSTEM",
  "uuid": "d891f6df-306c-49b1-8c0d-da96785603b9"
}