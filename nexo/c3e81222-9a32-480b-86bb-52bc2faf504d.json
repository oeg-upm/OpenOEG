{
  "message": "SYSTEM: RQRQR.pdf: Página 9\n‘N’\n‘G’\n‘F’\n1 Water(x) ←DrainsAt(x, y)\nYes\nYes\nYes\n2 DrainsAt(x, drains(x)) ←RunningWater(x)\nYes\nYes\nYes\n3 RunningWater(x) ←River(x)\nYes\nYes\nYes\n4 River(x) ←Tributary(x)\nYes\nNo\nNo\n5 RunningWater(x) ←Stream(x)\nYes\nNo\nNo\n6 Water(x) ←StillWater(x)\nYes\nYes\nYes\n7 StillWater(x) ←Enclosure(x)\nYes\nYes\nYes\n8 Enclosure(x) ←SaltMarsh(x)\nYes\nYes\nNo\n9 SaltMarsh(x) ←SalineGround(x)\nYes\nYes\nNo\n10 Morphology(x) ←FloodableArea(x)\nYes\nYes\nNo\nTable 2. Clauses kept after pruning\ndoes not contain non retrievable predicates, but keeps the capability of retrieving\nall the answers, some resolution steps that would rely on non-mapped predicates\nhave to be performed.\nOnce that the saturated datalog program is obtained as described in [11], we\npropose the execution of a new stage, focused on the prevention of inﬁnite loops.\nTo achieve this, we apply resolution to the clauses that contain non retriev-\nable predicates so the resolution that would be done with clauses that contain\nnon-mapped predicates in the next phase is done in this one. This way, all the\ninferences enabled by these clauses are already done at this phase and the cor-\nresponding clauses can be safely removed from the datalog program, pruning it\nwithout loss of generality.\nThe selection function in this case will select the unmapped atoms in the\nbody of the clauses, if there are any. If not, the head will be selected in case that\nit is not mapped. This way, every inference made will remove one unmapped\natom in the body of a clause, unifying it with the head of another clause, whose\nbody will contain only mapped predicates, thus generating a clause that has\nat most one unmapped atom less than the base clause of the inference. After\nsaturation has been performed using this selection function and no new clauses\ncan be generated the clauses that contain unmapped predicates can be removed\nsafely, without removing any valid answer with them.\nResuming the example from section 3.1 the saturation process would execute\niterations and generate new clauses used for the inference in the next iteration,\nuntil there are no new clauses to generate and the saturation process ﬁnishes.\nThis is explained in context with the previous example next. Before the sat-\nuration starts we have the ontology pruned, we will use the “global” strategy\nwhich is more convenient for the explanatory purposes of the example, and the\ncontents are the following:\nQ(x) ←Water(x)\n(1)\nWater(x) ←DrainsAt(x, y)\n(2)\n",
  "speaker": "SYSTEM",
  "uuid": "c3e81222-9a32-480b-86bb-52bc2faf504d"
}