{
  "message": "SYSTEM: D5.3.1-v1.0.pdf: Página 26\nPage 26 of 111 \nNeOn Integrated Project EU-IST-027595 \n \nOne risk with the incremental approach is that the first releases address such a limited set of \nrequirements that the customer could be dissatisfied; one opportunity on the other hand is that \nwrong or missing requirements can be corrected in time. \nThere are some types of systems where incremental development and delivery is not the best \napproach. These are very large systems where development may involve teams working in \ndifferent locations, some embedded systems where the software depends on hardware \ndevelopment and some critical systems where all the requirements must be analysed to check for \ninteractions that may compromise the safety or security of the system [52]. \n2.3.4. Iterative development life cycle model \nThe iterative development [46] also divides the system into small parts, as the incremental \ndevelopment. However, instead of building and delivering a new and complete subsystem in each \ncycle, the iterative model proposes to build and deliver in each cycle a system with of all the \nsubsystems partially developed, being the functionalities of each subsystem improved in each new \ncycle. At the end of the cycle, an improved new version of the complete system is delivered to the \nuser. \nThis life cycle model has as purpose to reduce the risk between the user needs and the final \nproduct; it consists in the iteration of several waterfall life cycles. At the end of each iteration, an \nimproved or refined version of the software product is delivered to the user.  \n2.3.5. Evolutionary prototyping life cycle model  \nThe evolutionary prototyping model [19] is based on the assumption that it is often difficult to know \nall the system requirements at the beginning of a project and that the requirements can change \nduring the project life. Following an evolutionary prototyping life cycle model [19], the developers \nconstruct a partial implementation of the system which meets the known requirements. The \nprototype is rigorously developed by means of incorporating the best understood requirements. \nThe prototype is then evaluated and used by its intended users and the requirements are refined \nbased on such evaluation. \nEvolutionary prototyping implies that software developers do not know all of the requirements up \nfront, and so they need to experiment with an operational system in order to learn them; however, \nin the case of evolutionary prototypes software developers are more likely to start with those \nsystem aspects that are best understood and thus they build upon their strengths.  \nThis kind of model is used when the user does not know exactly what he wants, or when what the \nuser wants is not understood by the development team, or when the viability of the solution is not \nclear. Furthermore, in this model a high degree of uncertainty is assumed. \n2.3.6. Rapid throwaway prototyping life cycle model  \nThe rapid throwaway prototyping approach [19] addresses the issue of ensuring that the software \nproduct being proposed really meets the users’ needs. The approach is to construct a “quick and \ndirty” partial implementation of the system prior to (or during) the requirements stage. The potential \nusers utilize and evaluate this prototype for a period of time and supply the developers with \nfeedback concerning its strengths and weaknesses. This feedback is then used to modify the \nsoftware requirements specification to reflect the real user needs. At this point, the developers can \nproceed with the actual system design and implementation with the confidence that they are \nbuilding the “right” system (except in those cases where the user needs evolve). Note that in the \n",
  "speaker": "SYSTEM",
  "uuid": "8339219c-3b08-4509-b455-6bb49cee2eca"
}