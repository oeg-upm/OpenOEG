{
  "message": "SYSTEM: RQRQR.pdf: Página 10\nDrainsAt(x, drains(x)) ←RunningWater(x)\n(3)\nRunningWater(x) ←River(x)\n(4)\nWater(x) ←StillWater(x)\n(5)\nStillWater(x) ←Enclosure(x)\n(6)\nEnclosure(x) ←SaltMarsh(x)\n(7)\nSaltMarsh(x) ←SalineGround(x)\n(8)\nMorphology(x) ←FloodableArea(x)\n(9)\nIn this case the saturation process does not perform any inference, so these are\nthe clauses that serve as input in the added stage for the removal of non-mapped\npredicates. The resolution performed takes clauses two by two, ﬁrst trying with\nall the combinations of the initial knowledge base and then, as new clauses are\ngenerated, with those clauses and all the previous clauses. This procedure always\ntakes a non-mapped predicate in the body of a clause and uniﬁes this predicate\nwith the head of other clause that does not contain any non-mapped predicates\nin the body, thus every inference step generates a clause with at least one non-\nmapped predicate less than the clauses used to infer it, proving convergence. In\nour example the mapped predicates are River, Enclosure and SalineGround.\nIn the ﬁrst step of the resolution we get:\nfrom(3)and(4) : DrainsAt(x, drains(x)) ←River(x)\n(10)\nfrom(5)and(6) : Water(x) ←Enclosure(x)\n(11)\nfrom(7)and(8) : Enclosure(x) ←SalineGround(x)\n(12)\nIn the second step of the resolution we get:\nfrom(2)and(10) : Water(x) ←River(x)\n(13)\nfrom(1)and(11) : Q(x) ←Enclosure(x)\n(14)\nSimilarly, in the third step we get:\nfrom(2)and(10) : Water(x) ←River(x)\n(15)\nAnd ﬁnally in the fourth step we get:\nfrom(2)and(10) : Q(x) ←River(x)\n(16)\nAfter pruning the clauses that contain non-mapped predicates we get the\nfollowing datalog program:\nQ(x) ←Enclosure(x)\n(17)\nQ(x) ←River(x)\n(18)\nEnclosure(x) ←SalineGround(x)\n(19)\n",
  "speaker": "SYSTEM",
  "uuid": "e852fe61-1643-4c50-a022-e547c8390128"
}