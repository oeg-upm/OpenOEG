{
  "message": "SYSTEM: OntologyDebugging_KCAP2009.pdf: Página 3\n• \n...Some chocolate plus some milk?  \nCakeRecipe ⊆ ∃contain.Chocolate and ∃contain.Milk  \n• \n...Chocolate-flavoured milk?  \nCakeRecipe ⊆ ∃contain.(Chocolate∩Milk)  \n• \n...Some chocolate or some milk?  \nCakeRecipe ⊆ ∃contain.(Chocolate∪Milk)  \nAntiPattern OnlynessIsLoneliness (OIL) \nC1⊆∀R.C2, C1⊆∀R.C3, disj(C2,C3)  \nThe ontology has a universal restriction to say that C1 can \nonly be linked with property R to C2. Next, a new universal \nrestriction is added saying that C1 can only be linked with \nproperty R to C3, disjoint with C2. In general, this means \nthat the ontology developer forgot the previous axiom. \nAntiPattern OnlynessIsLonelinessWithInheri-\ntance (OILWI) \nC1⊆C2, C1⊆∀R.C3, C2⊆∀R.C4, disj(C3,C4)  \nThe ontology developer has added a universal restriction \nfor class C1 without remembering that he had already de-\nfined another universal restriction with the same property in \na parent class. This anti-pattern is a specialization of OIL. \nAntiPattern OnlynessIsLonelinessWithProperty-\nInheritance (OILWPI) \nR1⊆R2, C1⊆∀R1.C2, C1⊆∀R2.C3, disj(C2,C3)  \nThe ontology developer misunderstands the subproperty \nrelation between roles, thinking that it is similar to a part-of \nrelation. This anti-pattern is a specialization of OIL because \nC1⊆∀R1.C2, R1⊆R2 ╞ C1⊆∀R2.C2. \nAntiPattern UniversalExistence (UE) \nC1⊆∀R.C2, C1⊆∃R.C3, disj(C2,C3)  \nThe ontology developer has added an existential restriction \nfor a concept without remembering the existence of an in-\nconsistency-leading universal restriction for that concept. \nAntiPattern UniversalExistenceWithInheritance \n(UEWI) \nC1⊆C2, C1⊆∃R.C3, C2⊆∀R.C4, disj(C3,C4) or  \nC1⊆C2, C1⊆∀R.C3, C2⊆∃R.C4, disj(C3,C4) \nThe ontology developer has added an existential/universal \nrestriction in a concept without remembering that there was \nalready an inconsistency-leading universal/existential re-\nstriction in a parent class, respectively. This anti-pattern is a \nspecialization of UE. \nAntiPattern UniversalExistenceWithPropertyIn-\nheritance1 (UEWPI) \nR1⊆R2, C1⊆∃R1.C2, C1⊆∀R2.C3, disj(C2,C3) \nThe ontology developer misunderstands the subproperty \nrelation between roles, thinking that it is similar to a part-of \nrelation. This anti-pattern is a specialization of UE because \nC1⊆∃R1.C2, R1⊆R2 ╞ C1⊆∃R2.C2. \nAntiPattern UniversalExistenceWithInverseProp-\nerty (UEWIP) \nC2⊆∃R-1.C1, C1⊆∀R.C3, disj(C2, C3) \nThe ontology developer has added restrictions about C2 \nand C1 using a role and its inverse. This antipattern is a \nspecialization of UE because: C2⊆∃R-1.C1 ╞ C1⊆∃R.C2.  \nAntiPattern EquivalenceIsDifference (EID) \nC1 ≡ C2, disj(C1,C2)  \nThis inconsistency comes from the fact that the ontology \ndeveloper wants to say that C1 is a subclass of C2 (that is, \nthat C1 is a C2, but at the same time it is different from C2 \nsince he has more information). This anti-pattern is only \ncommon for ontology developers with no previous training \nin OWL modelling, since after a short training session they \nwould discover that they really want to express C1⊆C2. \n2.3 Non Logical Anti-Patterns \nAs aforementioned, these anti-patterns are not necessarily \nerrors, but describe common templates that ontology devel-\nopers use erroneously trying to represent a different piece \nof knowledge. \nAntiPattern SynonymeOfEquivalence (SOE) \nC1 ≡ C2  \nThe ontology developer wants to express that two classes \nC1 and C2 are identical. This is not very useful in a single \nontology that does not import others. Indeed, what the on-\ntology developer generally wants to represent is a termino-\nlogical synonymy relation: the class C1 has two labels: C1 \nand C2. Usually one of the classes is not used anywhere \nelse in the axioms defined in the ontology.  \nAntiPattern SumOfSome (SOS)  \nC1⊆∃R.C2, C1⊆∃R.C3, disj(C2,C3) \nThe ontology developer has added a new existential restric-\ntion without remembering that he has already defined an-\nother existential restriction for the same concept and role. \nAlthough this could be ok in some cases (e.g., a child has at \nleast one mother and at least one father), in many cases it \nrepresents a modelling error. \nAntiPattern SumOfSomeWithInheritance \n(SOSWI) \nC1⊆C2, C1⊆∃R.C3, C2⊆∃R.C4, disj(C3,C4) \nThis anti-pattern is a specialization of SOS. \nAntiPattern SumOfSomeWithPropertyInheritance \n(SOSWPI) \nR1⊆R2, C1⊆∃R1.C2, C1⊆∃R2.C3, disj(C2,C3) \n",
  "speaker": "SYSTEM",
  "uuid": "bd7bf3b9-e226-4a6c-8fb3-4343c6bc59d5"
}