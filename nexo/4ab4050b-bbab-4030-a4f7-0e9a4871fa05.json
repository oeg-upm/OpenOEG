{
  "message": "SYSTEM: Eswc2010webofdatatrack_submission_2.pdf: Página 5\nQuery Plan from this internal representation. The query optimizer is in charge of \napplying different optimizations depending on the type of DQP system, the physical \nstate of the system, which indices to use, which nodes to send the query to, etc. As a \nresult, the query optimizer generates an optimized query plan that specifies how the \nquery is going to be executed. This plan is refined and transformed into an executable \nplan by the plan refinement component. This plan will be executed by the query \nexecution engine in each local node. The query execution engine provides generic \nimplementations for every operator in the query plan. Finally, the catalog (or \nmetadata) component stores information about the databases (schema, tables, views or \nphysical information about it), which can be used during parsing, query rewriting and \nquery optimization. \n \nFigure 1: Most common phases of query processing. \nThis is a generic architecture, which can be adapted depending on the types of data \nsources that are handled, on the type of metadata available, etc. One of the most \nimportant elements in this architecture, since it heavily influences the quality of the \nDQP system, is the query optimizer. Some of the most common optimizations that \nmay be performed by this component are the following:  \n• \nCost estimation. These optimizers may use cost estimations based on resource \nconsumption or on response time. The classic cost model estimates the cost of \nevery individual operator of the plan and sums the cost of all the operators that \nare in the LQP. The cost of a plan is then defined as the resource consumption of \nthe operator and the total cost of the plan is the cost of executing all operators in \nthe LQP. A problem of this cost model is that it does not take into account intra-\nquery parallelism. Another cost estimation method is the response time model. In \nthis cost model the response between data nodes is taken into account. The model \nconsiders if a query can be parallelized in two different data nodes, taking into \naccount the cost of the communications in the network. \n• \nPlan enumeration with dynamic programming. Iterative dynamic programming \nalgorithms build complex subplans from simpler plans. In each iteration, the \nalgorithm selects the plan with minimal cost and updates the existing plan list. \nThe result is the plan with minimal cost. The main drawbacks of this algorithm \nare related to its computational complexity (which is exponential in terms of time \nand space) and to its dependence on the quality of the cost function used to \ncalculate the cost of each operation. \n• \nSite selection. Every site has annotations that indicate where the operator is to be \nexecuted, and operators can be executed either at the client side or at the server \n",
  "speaker": "SYSTEM",
  "uuid": "4ab4050b-bbab-4030-a4f7-0e9a4871fa05"
}