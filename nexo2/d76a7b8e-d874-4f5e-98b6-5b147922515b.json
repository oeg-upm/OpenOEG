{
  "message": "SYSTEM: Eswc2010webofdatatrack_submission_2.pdf: Página 9\noriginal query using SQL operators. Normally, the first operator to be applied is the \nRDF Scan, which retrieves all the triples from an RDF dataset (this would be in \ngeneral very inefficient, since a data set may contain a huge amount of RDF triples); \nthen the Select operator would be applied (which selects the triples from the triples \ninitially retrieved from the Scan operator), and finally a Project operator would be \napplied (which contains the variable to be retrieved from the RDF triples). The \nRDFTableScanImplosion optimizer unifies these operations into a single one in order \nto perform at the RDF dataset the most restricting query. An example is the following: \nthe \nSPARQL \nquery \ncontains \na \ntriple \npattern \n\"?band \np:genre \n<http://dbpedia.org/resource/Madchester>\". The translation into a LQP is RDF Scan \n(select \n* \nwhere \n{?s \n?p \n?o}), \nSelect \n(p<-p:genre, \no<- \n<http://dbpedia.org/resource/Madchester>) and next the Project operator (?p <- \n?band). Using the optimization the query that is done to the triple store is select  * \nwhere {?band p:genre <http://dbpedia.org/resource/Madchester>. }.  \nBesides the RDFTableScanImplosion optimizer, we also use a normalizer (which \nnormalizes the LQP removing unnecessary operators) and a query partitioner \n(explained in the next section).  \nSPARQL-D Query Partitioner. The previous query plan is partitioned into \nsubqueries addressed to the nodes where they will be executed. OGSA-DQP provides \nan algorithm in charge of partitioning the logical query plan according to the data \nnodes from which the data is retrieved. If a query plan contains a join or product of \ntwo data streams that are located on different data nodes, the partitioning algorithm \ndetects this and transforms the LQP by inserting exchange operators that represent \ndata transfers between two remote data nodes. The output from the partitioner is a set \nof partitions and the LQP where every operator is annotated with the partition to \nwhich it belongs. In our approach we have directly used the OGSA-DQP partitioner \noptimizer, since the LQP partitioning logic is the same in both situations. \n3.3 SPARQL-DQP implementation \nIn this section we describe the implementation details of the SPARQL-DQP system. \nBesides the previously described work on query parsing, logical query plan \ngeneration, optimization and partitioning, following a classical approach, we also base \nour implementation in the use of Web Service-based access to data sources, as a result \nof our choice of implementation. A reason for selecting a WS-based approach for \naccessing RDF data sources is the availability of indirect access modes, which are not \ncommon in the current state of the art in SPARQL centralized and distributed \nquerying. We will first provide some background on this type of access to data \nsources, and will then describe more details about our implementation. \n",
  "speaker": "SYSTEM",
  "uuid": "d76a7b8e-d874-4f5e-98b6-5b147922515b"
}